#!/bin/sh
#
# print-pid
# =========
#
# Runs a specified command and prints its process ID and exit status.
# This small script is useful for Redelmeier's cpuburn programs which print
# nothing to stdout.
#
#
# Licensed under the GNU General Public License, version 2 or later.
# This program comes with ABSOLUTELY NO WARRANTY. See the GNU GPL for details:
# <https://www.gnu.org/licenses/old-licenses/gpl-2.0.html>
#
# Written by Explorer.
# Last updated on 27 July 2016.


set +m
if [ "X$1" = X ] || [ "X$1" = X--help ]; then
    echo "Usage: $0 COMMAND [ARGS]"
    exit 1
fi

if [ -x "`which -- "$1"`" ]; then
    # User-defined signals will be propagated transparently to child.
    # Don't terminate or stop upon stdio-related signals. This parent shall
    # concentrate on waiting. If the child dies or stops upon any of such
    # signal on its own, so be it.
    # The shell can 'wait' for stopped processes when job control is NOT
    # active, otherwise the 'wait' builtin returns early. (This behavior isn't
    # well documented. Beware.)
    trap '' USR1 USR2 PIPE TTIN TTOU XFSZ
    "$@" & PID=$!
    trap 'trap - 2 3 14 15; kill $PID; kill -s CONT $PID' 2 3 14 15
    trap 'trap - HUP; kill -s HUP $PID $$' HUP
    for s in USR1 USR2 CONT; do
        trap "kill -s $s $PID" $s
    done
    trap "kill -s TSTP $PID; kill -s STOP $$" TSTP
    echo "print-pid: [`date +'%b %d %T'`] PID $PID, '$@ &' started."
    wait $PID; STATUS=$?
    trap - 1 2 3 14 15 USR1 USR2 CONT
    SIG=""
    if [ "$STATUS" -gt 128 ] && [ "$STATUS" -le 159 ]; then
        SIG=" (`kill -l "$STATUS"`)"
    fi
    echo "print-pid: [`date +'%b %d %T'`] PID $PID exited with status $STATUS$SIG."
    exit $STATUS
else
    echo "print-pid ERROR: '$1' is not executable." >&2
    echo "Usage: $0 COMMAND [ARGS]" >&2
    exit 1
fi
