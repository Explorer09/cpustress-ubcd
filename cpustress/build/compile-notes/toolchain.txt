15 September 2018

The compilers in Ubuntu (or other modern Linux distros) are configured to
generate i686-only code by default. If you compile programs with the native
toolchain, the programs may not work with older CPUs due to new instructions
like CMOV. Although for some programs you may avoid the problem by specifying
'-march' compiler flag (Linux kernel and BusyBox did this automatically), the
main C library cannot be built this way. As the C library depends on several
compiled code in libgcc, building it to work with i486 CPUs requires building
the whole toolchain. This document describes how to build a cross-toolchain for
CPUstress image.

I build this toolchain on Ubuntu 12.04.5 LTS (64-bit). Other distros are not
tested.

This document assumes that you are familiar with the build process of GNU
toolchain, thus many explanations of the command-line options are omitted.

The build process is similar to the one described in "EGLIBC.cross-building"
document in the EGLIBC source. For explanation of each step, it is good to read
the document before building the tools below.

For beginners, the Linux From Scratch <http://www.linuxfromscratch.org/lfs/>
book is also useful. However, there are differences in the procedure between
in the book and below, which are noted.

This document may be converted to a workable shell script. To do this, run
"doc-to-sh.sh".

First, prepare an empty directory for building the toolchain:

 $ mkdir toolchain || :
 $ cd toolchain

Preparation
-----------

 $ download () {
     wget http://ftp.gnu.org/gnu/binutils/binutils-2.31.1.tar.xz
     wget https://gmplib.org/download/gmp/gmp-6.1.2.tar.xz
     wget http://www.mpfr.org/mpfr-current/mpfr-4.0.1.tar.xz
     wget -O mpfr-allpatches.patch http://www.mpfr.org/mpfr-current/allpatches
     wget https://ftp.gnu.org/gnu/mpc/mpc-1.1.0.tar.gz
     wget ftp://gcc.gnu.org/pub/gcc/infrastructure/isl-0.18.tar.bz2
     wget ftp://ftp.gnu.org/gnu/gcc/gcc-8.1.0/gcc-8.1.0.tar.xz
     wget https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.16.9.tar.xz
     svn export http://www.eglibc.org/svn/branches/eglibc-2_19/libc/
     }
 $ extract () {
     tar -x --xz -f binutils-2.31.1.tar.xz
     tar -x --xz -f gmp-6.1.2.tar.xz
     tar -x --xz -f mpfr-4.0.1.tar.xz
     tar -x -z -f mpc-1.1.0.tar.gz
     tar -x --bzip2 -f isl-0.18.tar.bz2
     tar -x --xz -f gcc-8.1.0.tar.xz
     tar -x --xz -f linux-4.16.9.tar.xz
     mv gmp-6.1.2  gcc-8.1.0/gmp
     mv mpfr-4.0.1 gcc-8.1.0/mpfr
     mv mpc-1.1.0  gcc-8.1.0/mpc
     mv isl-0.18   gcc-8.1.0/isl
     }

 $ download
 $ extract
 $ for i in binutils-2.31.1 gcc-8.1.0 linux-4.16.9 libc
     do [ -d "$i" ] || exit 1 ; done

Copy the "option-groups.config" file from the compile-notes directory to
the current directory where we have the source code. (You need to do this
manually - the script can't locate where the file is.)

 $ [ -f option-groups.config ] || exit 1

Apply the official cumulative patch for MPFR:
(Note: the version of latest MPFR patch before this build is 4.0.1-p6.)

 $ cd gcc-8.1.0/mpfr
 $ patch -p 1 < ../../mpfr-allpatches.patch
 $ cd ../..

Make 'sysroot' and 'tools' directories:

 $ mkdir sysroot   || : # This stores i486 target libraries & include files.
 $ mkdir sysroot64 || : # This stores x86_64 target libraries & include files.
 $ mkdir tools     || : # This stores the cross-compile tools (binutils & GCC).
 $ for i in sysroot sysroot64 tools
     do [ -d "$i" ] || exit 1 ; done
 $ SYSROOT_DIR=${PWD}/sysroot
 $ SYSROOT64_DIR=${PWD}/sysroot64
 $ TOOLS_DIR=${PWD}/tools

Add the 'tools' directory to PATH, so that our cross tools (binutils & GCC) can
be found as soon as they are available.

 $ export PATH="${TOOLS_DIR}/bin:${PATH}"

All of the binutils, GCC, and glibc documentation recommend building them in a
separate build directory (while glibc REQUIRES that), so make the build
directories:

 $ mkdir binutils-build gcc-build eglibc-build

Note that we will clean up (make -k distclean || : ; rm -r *) and remove the
build directories as soon as they are no longer needed.

1. Cross-binutils
-----------------

 $ cd binutils-build

In case that the output of config.guess matches the system type we specify in
--target (or --host later for building libc), we hack the string so that
configure will always build cross tools and not native ones:

 $ BUILD=$(../binutils-2.31.1/config.guess | sed -e 's/-pc-/-buildpc-/')

 $ ../binutils-2.31.1/configure --prefix="${TOOLS_DIR}" --build=${BUILD} \
     --target=i486-pc-linux-gnu --with-sysroot="${SYSROOT_DIR}"
 $ make
 $ make install
 $ make -k distclean || :
 $ rm -r *

 $ ../binutils-2.31.1/configure --prefix="${TOOLS_DIR}" --build=${BUILD} \
     --target=x86_64-pc-linux-gnu --with-sysroot="${SYSROOT64_DIR}"
 $ make
 $ make install
 $ make -k distclean || :
 $ rm -r *

 $ cd ..
 $ rmdir binutils-build

2. Cross-GCC without libc headers
---------------------------------

These target libraries cannot be built because we have no libc in the target
system. Disable these until we have EGLIBC in the final build of GCC:

 $ DISABLE_TARGET_LIBS="
     --disable-libstdcxx --disable-libsanitizer --disable-libmpx
     --disable-libvtv --disable-libssp --disable-libquadmath --disable-libgomp
     --disable-libitm --disable-libatomic"

For some complex (and largely political) reasons, the unwind tables (i.e. the
.eh_frame section) are always included in binary even when we have no chance to
use them (i.e. no exception handling or in-code backtracing, and we have no
intention to debug the code). Because the .eh_frame sections cannot be stripped
after they're generated, to reduce binary size, we suppress its generation
except where -fasynchronous-unwind-tables is used explicitly:

 $ GCC_CONFIGURE_SPECS=$(printf '%s%s' \
     '%{!fasynchronous-unwind-tables:%{!fno-asynchronous-unwind-tables:' \
     '-fno-asynchronous-unwind-tables}}')

 $ cd gcc-build
 $ BUILD=$(../gcc-8.1.0/config.guess | sed -e 's/-pc-/-buildpc-/')

 $ ../gcc-8.1.0/configure --prefix="${TOOLS_DIR}" --build=${BUILD} \
     --target=i486-pc-linux-gnu --enable-languages=c \
     --disable-shared --disable-threads --disable-lto \
     --disable-bootstrap --disable-multilib ${DISABLE_TARGET_LIBS} \
     --without-headers --with-newlib \
     --with-sysroot="${SYSROOT_DIR}" --with-specs="${GCC_CONFIGURE_SPECS}" \
     --with-arch-32=i486 --with-tune=generic
 $ make
 $ make install-strip
 $ make -k distclean || :
 $ rm -r *

 $ ../gcc-8.1.0/configure --prefix="${TOOLS_DIR}" --build=${BUILD} \
     --target=x86_64-pc-linux-gnu --enable-languages=c \
     --disable-shared --disable-threads --disable-lto \
     --disable-bootstrap --disable-multilib ${DISABLE_TARGET_LIBS} \
     --without-headers --with-newlib \
     --with-sysroot="${SYSROOT64_DIR}" --with-specs="${GCC_CONFIGURE_SPECS}" \
     --with-arch-32=i486 --with-tune=generic
 $ make
 $ make install-strip
 $ make -k distclean || :
 $ rm -r *

 $ cd ..

Notes:
* The --with-arch-32=i486 and --with-tune=generic options ensure that the new
  target code compiled after this new compiler will support i486 (-march=i486)
  and be tuned for generic CPUs (-mtune=generic) by default.
* Without libc headers, the TARGET_LIBC_PROVIDES_SSP macro should be undefined
  (in "gcc/auto-host.h") now. Trying to build glibc at this time will result in
  "undefined reference to __stack_chk_guard" error. Linux From Scratch used to
  solve this by specifying "gcc_cv_libc_provides_ssp=yes" argument in configure
  script (a hack). The --with-glibc-version option (new in GCC 4.9) was also
  designed to solve this problem and allow glibc to be built with the initial
  compiler (with no libc headers or shared libgcc). However, the libc binaries
  built with the initial compiler won't be bit-identical to the binaries
  rebuilt later, so I don't take either approach.

3. Linux kernel headers for libc
--------------------------------

 $ cd linux-4.16.9
 $ make mrproper
 $ make INSTALL_HDR_PATH="${SYSROOT_DIR}/usr" headers_install
 $ make INSTALL_HDR_PATH="${SYSROOT64_DIR}/usr" headers_install
 $ cd ..

4. EGLIBC headers and startup files
-----------------------------------

 $ cd eglibc-build
 $ BUILD=$(../libc/scripts/config.guess | sed -e 's/-pc-/-buildpc-/')

 $ cp ../option-groups.config .
 $ ../libc/configure --prefix=/usr --libexecdir=/usr/lib --build=${BUILD} \
     --host=i486-pc-linux-gnu --enable-kernel=2.6.36 --enable-add-ons=nptl \
     --disable-nscd --disable-profile --without-gd --without-selinux \
     --with-headers="${SYSROOT_DIR}/usr/include"

Install libc headers:

 $ make install-headers install-bootstrap-headers=yes \
     install_root="${SYSROOT_DIR}"

Make startup files (crt*.o):

 $ make csu/subdir_lib
 $ mkdir "${SYSROOT_DIR}/usr/lib"
 $ cp csu/crt*.o "${SYSROOT_DIR}/usr/lib"

Make dummy libc.so:

 $ i486-pc-linux-gnu-gcc -nostdlib -shared -x c /dev/null \
     -o "${SYSROOT_DIR}/usr/lib/libc.so"

 $ make -k distclean || :
 $ rm -r *

Do the same for x86_64:

 $ cp ../option-groups.config .
 $ ../libc/configure --prefix=/usr --libexecdir=/usr/lib --build=${BUILD} \
     --host=x86_64-pc-linux-gnu --enable-kernel=2.6.36 --enable-add-ons=nptl \
     --disable-nscd --disable-profile --without-gd --without-selinux \
     --with-headers="${SYSROOT64_DIR}/usr/include"

 $ make install-headers install-bootstrap-headers=yes \
     install_root="${SYSROOT64_DIR}"

 $ make csu/subdir_lib
 $ mkdir "${SYSROOT64_DIR}/usr/lib" "${SYSROOT64_DIR}/usr/lib64"
 $ cp csu/crt*.o "${SYSROOT64_DIR}/usr/lib64"

 $ x86_64-pc-linux-gnu-gcc -nostdlib -shared -x c /dev/null \
     -o "${SYSROOT64_DIR}/usr/lib64/libc.so"

 $ make -k distclean || :
 $ rm -r *

 $ cd ..

Note:
* "${SYSROOT64_DIR}/usr/lib" _must_ be created even though it's empty at this
  step, otherwise the absence of the directory will hinder the library search
  for the compiler that will be built later. (It searches "usr/lib/../lib64"
  instead of "usr/lib64" directly.)

5. Cross-GCC for building libc
------------------------------

Note the option '--enable-shared=libgcc'.

 $ cd gcc-build
 $ BUILD=$(../gcc-8.1.0/config.guess | sed -e 's/-pc-/-buildpc-/')

 $ ../gcc-8.1.0/configure --prefix="${TOOLS_DIR}" --build=${BUILD} \
     --target=i486-pc-linux-gnu --enable-languages=c \
     --enable-shared=libgcc --disable-threads --disable-lto \
     --disable-bootstrap --disable-multilib ${DISABLE_TARGET_LIBS} \
     --with-sysroot="${SYSROOT_DIR}" --with-specs="${GCC_CONFIGURE_SPECS}" \
     --with-arch-32=i486 --with-tune=generic
 $ make
 $ make install-strip
 $ make -k distclean || :
 $ rm -r *

 $ ../gcc-8.1.0/configure --prefix="${TOOLS_DIR}" --build=${BUILD} \
     --target=x86_64-pc-linux-gnu --enable-languages=c \
     --enable-shared=libgcc --disable-threads --disable-lto \
     --disable-bootstrap --disable-multilib ${DISABLE_TARGET_LIBS} \
     --with-sysroot="${SYSROOT64_DIR}" --with-specs="${GCC_CONFIGURE_SPECS}" \
     --with-arch-32=i486 --with-tune=generic
 $ make
 $ make install-strip
 $ make -k distclean || :
 $ rm -r *

 $ cd ..

6. EGLIBC, (mostly) full
------------------------

With "option-groups.config", this build of libc will have functionality just
enough for CPUstress and won't fit for everything. Please read "glibc.txt" for
more information. For example, this libc cannot be used to bootstrap a native
GCC compiler (a cross-compiler is fine, though).

 $ cd eglibc-build
 $ BUILD=$(../libc/scripts/config.guess | sed -e 's/-pc-/-buildpc-/')

 $ cp ../option-groups.config .
 $ ../libc/configure --prefix=/usr --libexecdir=/usr/lib --build=${BUILD} \
     --host=i486-pc-linux-gnu --enable-kernel=2.6.36 --enable-add-ons=nptl \
     --disable-nscd --disable-profile --without-gd --without-selinux \
     --with-headers="${SYSROOT_DIR}/usr/include"
 $ make
 $ make install install_root="${SYSROOT_DIR}"
 $ make -k distclean || :
 $ rm -r *

 $ cp ../option-groups.config .
 $ ../libc/configure --prefix=/usr --libexecdir=/usr/lib --build=${BUILD} \
     --host=x86_64-pc-linux-gnu --enable-kernel=2.6.36 --enable-add-ons=nptl \
     --disable-nscd --disable-profile --without-gd --without-selinux \
     --with-headers="${SYSROOT64_DIR}/usr/include"
 $ make
 $ make install install_root="${SYSROOT64_DIR}"
 $ make -k distclean || :
 $ rm -r *

 $ cd ..
 $ rmdir eglibc-build

7. Cross-GCC, full
------------------

This build of GCC enables threads, locales, LTO, and all target libraries.
Only libgcc is built with a shared library. Other target libraries, including
libstdc++, are built as static libraries only.

 $ cd gcc-build
 $ BUILD=$(../gcc-8.1.0/config.guess | sed -e 's/-pc-/-buildpc-/')

 $ ../gcc-8.1.0/configure --prefix="${TOOLS_DIR}" --build=${BUILD} \
     --target=i486-pc-linux-gnu --enable-languages=c,c++,lto \
     --enable-shared=libgcc --enable-threads=posix --enable-lto \
     --disable-bootstrap --disable-multilib \
     --with-sysroot="${SYSROOT_DIR}" --with-specs="${GCC_CONFIGURE_SPECS}" \
     --with-arch-32=i486 --with-tune=generic
 $ make
 $ make install-strip
 $ make -k distclean || :
 $ rm -r *

 $ ../gcc-8.1.0/configure --prefix="${TOOLS_DIR}" --build=${BUILD} \
     --target=x86_64-pc-linux-gnu --enable-languages=c,c++,lto \
     --enable-shared=libgcc --enable-threads=posix --enable-lto \
     --disable-bootstrap --disable-multilib \
     --with-sysroot="${SYSROOT64_DIR}" --with-specs="${GCC_CONFIGURE_SPECS}" \
     --with-arch-32=i486 --with-tune=generic
 $ make
 $ make install-strip
 $ make -k distclean || :
 $ rm -r *

 $ cd ..
 $ rmdir gcc-build

Final tuning
------------

Copy libgcc_s.so.1 from 'tools' directory to the target's 'sysroot' directory,
because GCC's makefile doesn't do this automatically when installing:

 $ cp -Pp "${TOOLS_DIR}"/i486-pc-linux-gnu/lib/libgcc_s.so.1 \
     "${SYSROOT_DIR}/lib"
 $ cp -Pp "${TOOLS_DIR}"/x86_64-pc-linux-gnu/lib64/libgcc_s.so.1 \
     "${SYSROOT64_DIR}/lib64"

GCC does not make binutils aware of GCC's LTO feature, so some programs (namely
ar, nm and ranlib) don't work with object codes compiled with LTO. Although GCC
provides wrapper programs (gcc-ar, gcc-nm, gcc-ranlib) to launch the LTO plugin
with the programs, it is better to let them load the plugin automatically,
without wrappers. Create a symlink in "lib/bfd-plugins" to achieve this:

 $ mkdir "${TOOLS_DIR}/lib/bfd-plugins"
 $ cd "${TOOLS_DIR}/lib/bfd-plugins"
 $ ln -s ../../libexec/gcc/x86_64-pc-linux-gnu/8.1.0/liblto_plugin.so.0.0.0 \
     liblto_plugin.so

Stripping binaries (Optional)
-----------------------------

The ".so" binary files in CPUstress are stripped binaries.

 $ cd "${SYSROOT_DIR}/lib"
 $ SO_FILES=$(find -type f -name '*.so*')
 $ i486-pc-linux-gnu-strip --strip-unneeded ${SO_FILES}
 $ cd "${SYSROOT64_DIR}/lib64"
 $ x86_64-pc-linux-gnu-strip --strip-unneeded ${SO_FILES}

Change mode bits (Optional)
---------------------------

 $ cd "${SYSROOT_DIR}/lib"
 $ chmod 644 ${SO_FILES}
 $ chmod 755 ld-2.19.so libc-2.19.so libpthread-2.19.so
 $ cd "${SYSROOT64_DIR}/lib64"
 $ chmod 644 ${SO_FILES}
 $ chmod 755 ld-2.19.so libc-2.19.so libpthread-2.19.so

 $ cd ../../..

Other notes
-----------

Building and using a GCC version older than one described in this document for
CPUstress is not recommended. Nevertheless, some options may be needed if you
try to configure an older GCC due to configure script limitations or bugs.
Below are non-exhaustive mentions, which I note only for historical reference:
(You might see them in older Linux From Scratch books or other toolchain build
instructions)
* Before GCC 4.9.0: Need also --disable-libmudflap in ${DISABLE_TARGET_LIBS}.
* Before GCC 5.1:   Use --disable-libstdc++-v3 instead of --disable-libstdcxx
  in ${DISABLE_TARGET_LIBS} because the latter (documented) option didn't work
  then due to a bug.
* Before GCC 8.1:   Need also --disable-libcilkrts in ${DISABLE_TARGET_LIBS}.
* Before GCC 4.6.0: You may add the following into ${GCC_CONFIGURE_SPECS}:
  '%{!fomit-frame-pointer:%{!fno-omit-frame-pointer:-fomit-frame-pointer}}'
  This tells GCC to -fomit-frame-pointer by default, where it was not then.
* Before GCC 4.2.0: Need to explicitly specify --enable-__cxa_atexit during
  final build of GCC. __cxa_atexit is needed for standard-compliant handling of
  destructors. Glibc provides it, but GCC didn't enable it by default for Linux
  targets yet then.
* Before GCC 4.6.0: Need to explicitly specify --enable-clocale=gnu during
  final build of GCC. This option was for libstdc++, otherwise libstdc++'s
  configure would be conservative and use 'generic' clocale model. (It was to
  workaround a bug that happened in glibc 2.2.*, but have been using a runtime
  test. Later libstdc++ releases require glibc 2.3+ and enable 'gnu' model by
  default when cross-compiling.)

The x86_64 ABI standard requires that .eh_frame section be always generated,
and for 32-bit x86, .eh_frame is generated as long as frame pointer is omitted
during code generation (which is default in GCC 4.6.0+).
(Reference: <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=49289>)
-fno-asynchronous-unwind-tables doesn't affect debugging, because the frame
unwinding tables will still get generated, but are stored to .debug_frame
section instead.

--Explorer <explorer09@gmail.com>
